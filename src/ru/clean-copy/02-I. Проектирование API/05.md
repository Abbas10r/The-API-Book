### Описание конечных интерфейсов

Определив все сущности, их ответственность и отношения друг с другом, мы переходим непосредственно к разработке API: нам осталось прописать номенклатуру всех объектов, полей, методов и функций в деталях. В этой главе мы дадим сугубо практические советы, как сделать API удобным и понятным.

Важное уточнение под номером ноль:

#### 0. Правила — это всего лишь обобщения

Правила не действуют безусловно и не означают, что можно не думать головой. У каждого правила есть какая-то рациональная причина его существования. Если в вашей ситуации нет причин следовать правилу — значит, следовать ему не надо.

Например, требование консистентности номенклатуры существует затем, чтобы разработчик тратил меньше времени на чтение документации; если вам _необходимо_, чтобы разработчик обязательно прочитал документацию по какому-то методу, вполне разумно сделать его сигнатуру нарочито неконсистентно.

Это соображение применимо ко всем принципам ниже. Если из-за следования правилам у вас получается неудобное, громоздкое, неочевидное API — это повод пересмотреть правила (или API).

Важно понимать, что вы вольны вводить свои собственные конвенции. Например, в некоторых фреймворках сознательно отказываются от парных методов `set_entity` / `get_entity` в пользу одного метода `entity` с опциональным параметром. Важно только проявить последовательность в её применении — если такая конвенция вводится, то абсолютно все методы API должны иметь подобную полиморфную сигнатуру, или по крайней мере должен существовать принцип именования, отличающий такие комбинированные методы от обычных вызовов.

#### 1. Явное лучше неявного

Из названия любой сущности должно быть очевидно, что она делает и к каким сайд-эффектам может привести её использование.
  * плохо:  
    ```
    GET /orders/cancellation
    отменяет заказ
    ```
    Неочевидно, что достаточно просто обращения к сущности `cancellation` (что это?), тем более немодифицирующим методом `GET`, чтобы отменить заказ;  

    Хорошо:  
    ```
      POST /orders/cancel
      отменяет заказ
    ```
  * плохо:
    ```
    GET /orders/statistics
    Возвращает агрегированную статистику заказов за всё время
    ```
    Даже если операция немодифицирующая, но вычислительно дорогая — следует об этом явно индицировать, особенно если вычислительные ресурсы тарифицируются для пользователя; тем более не стоит подбирать значения по умолчанию так, чтобы вызов операции без параметров максимально расходовал ресурсы.

    Хорошо:
    ```
    POST /orders/statistics/aggregate
    { "start_date", "end_date" }
    Возвращает агрегированную статистику заказов за указанный период
    ```

**Стремитесь к тому, чтобы из сигнатуры функции было абсолютно ясно, что она делает, что принимает на вход и что возвращает**. Вообще, при прочтении кода, работающего с вашим API, должно быть сразу понятно, что, собственно, он делает — без подглядывания в документацию.

#### 2. Сущности должны именоваться конкретно

Избегайте слов-«амёб» без определённой семантики, таких как get, apply, make. Сущности должны именоваться конкретно:
  * плохо: `user.get()` — неочевидно, что конкретно будет возвращено;  
    хорошо: `user.get_id()`;

#### 3. Не экономьте буквы

В XXI веке давно уже нет нужды называть переменные покороче.
  * плохо: `order.time()` — неясно, о каком времени идёт речь: время создания заказа, время готовности заказа, время ожидания заказа?…  
    хорошо: `order.get_estimated_delivery_time()`
  * плохо:
    ```
    strpbrk (str1, str2)
    возвращает положение первого вхождения в строку str2 любого символа из строки str2
    ```
    Возможно, автору этого API казалось, что аббревиатура `pbrk` что-то значит для читателя, но он явно ошибся. К тому же, невозможно сходу понять, какая из строк `str1`, `str2` является набором символов для поиска.
    Хорошо:
    ```
    str_search_for_characters(lookup_character_set, str)
    ```
    Однако необходимость существования такого метода вообще вызывает сомнения, достаточно было бы иметь удобную функцию поиска подстроки с нужными параметрами. Аналогично сокращение `string` до `str` выглядит совершенно бессмысленным, но, увы, является устоявшимся для большого количества предметных областей.

#### 4. Тип поля должен быть ясен из его названия

Если поле называется `recipe` — мы ожидаем, что его значением является сущность типа `Recipe`. Если поле называется `recipe_id` — мы ожидаем, что его значением является идентификатор, который я могу найти в составе сущности `Recipe`.

Сущности-массивы должны именоваться во множественном числе или собирательными выражениями — `objects`, `children`; если это невозможно (термин неисчисляемый), следует добавить префикс или постфикс, не оставляющий сомнений:
  * плохо: `GET /news` — неясно, будет ли получена какая-то конкретная новость или массив новостей;
    хорошо: `GET /news-list`.

Аналогично, если ожидается булево значение, то из названия это должно быть очевидно, т.е. именование должно описывать некоторое качественное состояние, например, `is_ready`, `open_now`:
  * плохо: `"task.status": true` — неочевидно, что статус бинарен, плюс такое API будет нерасширяемым;  
    хорошо: `"task.is_finished": true`

Отдельно следует оговорить, что на разных платформах эти правила следует дополнить по-своему с учетом специфики first-class citizen-типов. Например, объекты типа `Date`, если таковые имеются, разумно индицировать с помощью, например, постфикса `_at` (`created_at`, `occurred_at`, etc).

#### 5. Подобные сущности должны называться подобно и вести себя подобным образом

  * плохо: `begin_transition` / `stop_transition`  
    — `begin` и `stop` — непарные термины; разработчик будет вынужден рыться в документации;  
    хорошо: `begin_transition` / `end_transition` либо `start_transition` / `stop_transition`;
  * плохо:  
    ```
    strpos(haystack, needle)
    Находит первую позицию позицию строки `needle` внутри строки `haystack`
    ```
    ```
    str_replace(needle, replace, haystack)
    Находит и заменяет все вхождения строки `needle` внутри строки `haystack` на строку `replace`
    ```
    Здесь нарушены сразу несколько правил:
      * написание неконсистентно в части знака подчеркивания;
      * близкие по смыслу методы имеют разный порядок аргументов `needle`/`haystack`; 
      * первый из методов находит только первое вхождение строки `needle`, а другой — все вхождения, и об этом поведении никак нельзя узнать из сигнатуры функций.

    Упражнение «как сделать эти интерфейсы хорошо» предоставим читателю.

#### 6. Использованные стандарты указывайте явно

К сожалению, человечество не в состоянии договориться о таких простейших вещах, как «начинать ли неделю с понедельника или с воскресенья», что уж говорить о каких-то более сложных стандартах.

Поэтому _всегда_ указывайте, по какому конкретно стандарту вы отдаёте те или иные величины. Исключения возможны только там, где вы на 100% уверены, что в мире существует только один стандарт для этой сущности, и всё население земного шара о нём в курсе.

  * Плохо: `"date":"11/12/2020"` — стандартов записи дат существует огромное количество, плюс из этой записи невозможно даже понять, что здесь число, а что месяц;  
    хорошо: `"iso_date":"2020-11-12"`.
  * Плохо: `"duration":5000` — пять тысяч чего?  
    Хорошо:  
    `"duration_ms":5000`  
    либо  
    `"duration":"5000ms"`  
    либо  
    `"duration":{"unit":"ms","value":5000}`

Отдельное следствие из этого правила — денежные величины *всегда* должны сопровождаться указанием кода валюты.

Также следует отметить, что в некоторых областях ситуация со стандартами настолько плоха, что как ни сделай — кто-то останется недовольным. Классический пример такого рода — порядок геокоординат ("широта-долгота" против "долгота-широта"). Здесь, увы, вам остаётся только смириться и проявлять выдержку при нападках на ваше API.

#### 7. Сохранение точности дробных чисел

Там, где это позволено протоколом, дробные числа с фиксированной запятой — такие, как денежные суммы, например — должны передаваться в виде специально предназначенных для этого объектов, например, Decimal или аналогичных.

Если в протоколе нет Decimal-типов (в частности, в JSON нет чисел с фиксированной запятой), следует либо привести к целому, либо использовать строковый тип.

