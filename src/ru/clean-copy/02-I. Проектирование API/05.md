### Описание конечных интерфейсов

Определив все сущности, их ответственность и отношения друг с другом, мы переходим непосредственно к разработке API: нам осталось прописать номенклатуру всех объектов, полей, методов и функций в деталях. В этой главе мы дадим сугубо практические советы, как сделать API удобным и понятным.

Важное уточнение под номером ноль:

#### 0. Правила — это всего лишь обобщения

Правила не действуют безусловно и не означают, что можно не думать головой. У каждого правила есть какая-то рациональная причина его существования. Если в вашей ситуации нет причин следовать правилу — значит, следовать ему не надо.

Например, требование консистентности номенклатуры существует затем, чтобы разработчик тратил меньше времени на чтение документации; если вам _необходимо_, чтобы разработчик обязательно прочитал документацию по какому-то методу, вполне разумно сделать его сигнатуру нарочито неконсистентно.

Это соображение применимо ко всем принципам ниже. Если из-за следования правилам у вас получается неудобное, громоздкое, неочевидное API — это повод пересмотреть правила (или API).

Важно понимать, что вы вольны вводить свои собственные конвенции. Например, в некоторых фреймворках сознательно отказываются от парных методов `set_entity` / `get_entity` в пользу одного метода `entity` с опциональным параметром. Важно только проявить последовательность в её применении — если такая конвенция вводится, то абсолютно все методы API должны иметь подобную полиморфную сигнатуру, или по крайней мере должен существовать принцип именования, отличающий такие комбинированные методы от обычных вызовов.

#### 1. Явное лучше неявного

Из названия любой сущности должно быть очевидно, что она делает и к каким сайд-эффектам может привести её использование.

  * **Плохо**:  
    ```
    // Отменяет заказ
    GET /orders/cancellation
    ```
    Неочевидно, что достаточно просто обращения к сущности `cancellation` (что это?), тем более немодифицирующим методом `GET`, чтобы отменить заказ;  

    **Хорошо**:  
    ```
    // Отменяет заказ
    POST /orders/cancel
    ```
  * **Плохо**:
    ```
    // Возвращает агрегированную статистику заказов за всё время
    GET /orders/statistics
    ```
    Даже если операция немодифицирующая, но вычислительно дорогая — следует об этом явно индицировать, особенно если вычислительные ресурсы тарифицируются для пользователя; тем более не стоит подбирать значения по умолчанию так, чтобы вызов операции без параметров максимально расходовал ресурсы.

    **Хорошо**:
    ```
    // Возвращает агрегированную статистику заказов за указанный период
    POST /orders/statistics/aggregate
    { "start_date", "end_date" }
    ```

**Стремитесь к тому, чтобы из сигнатуры функции было абсолютно ясно, что она делает, что принимает на вход и что возвращает**. Вообще, при прочтении кода, работающего с вашим API, должно быть сразу понятно, что, собственно, он делает — без подглядывания в документацию.

Два важных следствия:

**1.1.** Если операция модифицирующая, это должно быть очевидно из сигнатуры. В частности, не может быть модифицирующих операций за `GET`.

**1.2.** Если операция асинхронная, это должно быть очевидно из сигнатуры, **либо** должна существовать конвенция именования, позволяющая отличаться синхронные операции от асинхронных.

#### 2. Использованные стандарты указывайте явно

К сожалению, человечество не в состоянии договориться о таких простейших вещах, как «начинать ли неделю с понедельника или с воскресенья», что уж говорить о каких-то более сложных стандартах.

Поэтому _всегда_ указывайте, по какому конкретно стандарту вы отдаёте те или иные величины. Исключения возможны только там, где вы на 100% уверены, что в мире существует только один стандарт для этой сущности, и всё население земного шара о нём в курсе:

  * **плохо**: `"date":"11/12/2020"` — стандартов записи дат существует огромное количество, плюс из этой записи невозможно даже понять, что здесь число, а что месяц;  
    **хорошо**: `"iso_date":"2020-11-12"`.
  * **плохо**: `"duration":5000` — пять тысяч чего?  
    **хорошо**:  
    `"duration_ms":5000`  
    либо  
    `"duration":"5000ms"`  
    либо  
    `"duration":{"unit":"ms","value":5000}`.

Отдельное следствие из этого правила — денежные величины *всегда* должны сопровождаться указанием кода валюты.

Также следует отметить, что в некоторых областях ситуация со стандартами настолько плоха, что как ни сделай — кто-то останется недовольным. Классический пример такого рода — порядок геокоординат ("широта-долгота" против "долгота-широта"). Здесь, увы, есть только один работающий метод борьбы с фрустрацией — «блокнот душевного спокойствия», который будет описан в разделе II.

#### 3. Сохраняйте точность дробных чисел

Там, где это позволено протоколом, дробные числа с фиксированной запятой — такие, как денежные суммы, например — должны передаваться в виде специально предназначенных для этого объектов, например, Decimal или аналогичных.

Если в протоколе нет Decimal-типов (в частности, в JSON нет чисел с фиксированной запятой), следует либо привести к целому (путём домножения на указанный множитель), либо использовать строковый тип.

#### 4. Сущности должны именоваться конкретно

Избегайте слов-«амёб» без определённой семантики, таких как get, apply, make. Сущности должны именоваться конкретно:
  * **плохо**: `user.get()` — неочевидно, что конкретно будет возвращено;  
    **хорошо**: `user.get_id()`.

#### 5. Не экономьте буквы

В XXI веке давно уже нет нужды называть переменные покороче.

  * **Плохо**: `order.time()` — неясно, о каком времени идёт речь: время создания заказа, время готовности заказа, время ожидания заказа?…  
    **Хорошо**: `order.get_estimated_delivery_time()`
  * **Плохо**:
    ```
    // возвращает положение первого вхождения в строку str2
    // любого символа из строки str2
    strpbrk (str1, str2)
    ```
    Возможно, автору этого API казалось, что аббревиатура `pbrk` что-то значит для читателя, но он явно ошибся. К тому же, невозможно сходу понять, какая из строк `str1`, `str2` является набором символов для поиска.  
    **Хорошо**: `str_search_for_characters(lookup_character_set, str)`  
    Однако необходимость существования такого метода вообще вызывает сомнения, достаточно было бы иметь удобную функцию поиска подстроки с нужными параметрами. Аналогично сокращение `string` до `str` выглядит совершенно бессмысленным, но, увы, является устоявшимся для большого количества предметных областей.

#### 6. Тип поля должен быть ясен из его названия

Если поле называется `recipe` — мы ожидаем, что его значением является сущность типа `Recipe`. Если поле называется `recipe_id` — мы ожидаем, что его значением является идентификатор, который мы сможем найти в составе сущности `Recipe`.

Сущности-массивы должны именоваться во множественном числе или собирательными выражениями — `objects`, `children`; если это невозможно (термин неисчисляемый), следует добавить префикс или постфикс, не оставляющий сомнений:
  * **плохо**: `GET /news` — неясно, будет ли получена какая-то конкретная новость или массив новостей;
    **хорошо**: `GET /news-list`.

Аналогично, если ожидается булево значение, то из названия это должно быть очевидно, т.е. именование должно описывать некоторое качественное состояние, например, `is_ready`, `open_now`:
  * **плохо**: `"task.status": true` — неочевидно, что статус бинарен, плюс такое API будет нерасширяемым;  
    **хорошо**: `"task.is_finished": true`.

Отдельно следует оговорить, что на разных платформах эти правила следует дополнить по-своему с учетом специфики first-class citizen-типов. Например, объекты типа `Date`, если таковые имеются, разумно индицировать с помощью, например, постфикса `_at` (`created_at`, `occurred_at`, etc) или `_date`.

Если наименование сущности само по себе является каким-либо термином, способным смутить разработчика, лучше добавить лишний префикс или постфикс, чтобы избежать непонимания.

  * **Плохо**:
    ```
    // Возвращает список встроенных функций кофе-машины
    GET /coffee-machines/functions
    ```
    Слово "functions" многозначное; может означать и встроенные функции, и написанный код, и состояние (функционирует-не функционирует).  
    **Хорошо**: `GET /coffee-machines/builtin-functions-list`

#### 7. Подобные сущности должны называться подобно и вести себя подобным образом

  * **Плохо**: `begin_transition` / `stop_transition`  
    — `begin` и `stop` — непарные термины; разработчик будет вынужден рыться в документации.  
    **Хорошо**: `begin_transition` / `end_transition` либо `start_transition` / `stop_transition`.
  * **Плохо**:  
    ```
    // Находит первую позицию позицию строки `needle`
    // внутри строки `haystack`
    strpos(haystack, needle)
    ```
    ```
    // Находит и заменяет все вхождения строки `needle`
    // внутри строки `haystack` на строку `replace`
    str_replace(needle, replace, haystack)
    ```
    Здесь нарушены сразу несколько правил:
      * написание неконсистентно в части знака подчеркивания;
      * близкие по смыслу методы имеют разный порядок аргументов `needle`/`haystack`; 
      * первый из методов находит только первое вхождение строки `needle`, а другой — все вхождения, и об этом поведении никак нельзя узнать из сигнатуры функций.

    Упражнение «как сделать эти интерфейсы хорошо» предоставим читателю.

#### 8. Клиент всегда должен знать полное состояние системы

Правило можно ещё сформулировать так: не заставляйте клиент гадать.

  * **Плохо**:
    ```
    // Создаёт комментарий и возвращает его id
    POST /comments
    { "content" }
    →
    { "comment_id" }
    ```
    ```
    // Возвращает комментарий по его id
    GET /comments/{id}
    →
    {
      // Комментарий не опубликован
      // и ждёт прохождения капчи
      "published": false,
      "action_required": "solve_captcha",
      "content"
    }
    ```
    — хотя операция будто бы выполнена успешна, клиенту необходимо сделать дополнительный запрос, чтобы понять необходимость решения капчи. Между вызовами `POST /comments` и `GET /comments/{id}` клиент находится в состоянии кота Шрёдингера: непонятно, опубликован комментарий или нет, и как отразить это пользователю.  
    **Хорошо**:
    ```
    // Создаёт комментарий и возвращает его
    POST /comments
    { "content" }
    →
    { "comment_id", "published", "action_required", "content" }
    ```
    ```
    // Возвращает комментарий по его id
    GET /comments/{id}
    →
    { /* в точности тот же формат, 
       что и в ответе POST /comments */
       …
    }
    ```
    Вообще в 9 случаях из 10 (а фактически — всегда, когда размер ответа невелик) во всех отношениях лучше из любой модифицирующей операции возвращать полное состояние сущности в том же формате, что и из операции доступа на чтение.

