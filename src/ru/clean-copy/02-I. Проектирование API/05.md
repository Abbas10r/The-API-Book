### Описание конечных интерфейсов

Определив все сущности, их ответственность и отношения друг с другом, мы переходим непосредственно к разработке API: нам осталось прописать номенклатуру всех объектов, полей, методов и функций в деталях. В этой главе мы дадим сугубо практические советы, как сделать API удобным и понятным.

Важное уточнение под номером ноль:

0. Правила — это всего лишь обобщения. Они не действуют безусловно и не означают, что можно не думать головой. У каждого правила есть какая-то рациональная причина его существования. Если в вашей ситуации нет причин следовать правилу — значит, следовать ему не надо.
    * например, требование консистентности номенклатуры существует затем, чтобы разработчик тратил меньше времени на чтение документации; если вам _необходимо_, чтобы разработчик обязательно прочитал документацию по какому-то методу, вполне разумно сделать его сигнатуру нарочито неконсистентно;
    * важно понимать, что вы вольны вводить свои собственные конвенции. Например, в некоторых фреймворках сознательно отказываются от парных методов `set_entity` / `get_entity` в пользу одного метода `entity` с опциональным параметром. Важно только проявить последовательность в её применении — если такая конвенция вводится, то абсолютно все методы API должны иметь подобную полиморфную сигнатуру, или по крайней мере должен существовать принцип именования, отличающий такие комбинированные методы от обычных вызовов.

Это соображение применимо ко всем принципам ниже. Если из-за следования правилам у вас получается неудобное, громоздкое, неочевидное API — это повод пересмотреть правила (или API).

1. Явное лучше неявного. Из названия любой сущности должно быть очевидно, что она делает и к каким сайд-эффектам может привести её использование.
    * плохо: `GET /orders/cancellation` отменяет заказ  
      — неочевидно, что достаточно просто обращения к сущности `cancellation` (что это?), тем более немодифицирующим методом `GET`, чтобы отменить заказ;  
      хорошо: `POST /orders/cancel`;
    * плохо: `GET /orders/statistics` агрегирует статистику заказов за всё время  
      — даже если операция немодифицирующая, но вычислительно дорогая — следует об этом явно индицировать, особенно если вычислительные ресурсы тарифицируются для пользователя; тем более не стоит подбирать значения по умолчанию так, чтобы операция без параметров максимально расходовала ресурсы;  
      хорошо: `POST /orders/statistics/aggregate` с обязательным указанием периода агрегации в запросе.

2. Избегайте слов-«амёб» без определённой семантики, таких как get, apply, make. Сущности должны именоваться конкретно:
    * плохо: `user.get()`
      — неочевидно, что конкретно будет возвращено;  
      хорошо: user.`get_id()`;

3. Не экономьте буквы. В XXI веке давно уже нет нужды называть переменные покороче:
    * плохо: `order.time()`  
      — неясно, о каком времени идёт речь: время создания заказа, время готовности заказа, время ожидания заказа?…  
      хорошо: `order.get_estimated_delivery_time()`
    * плохо: `strpbrk` ищет вхождение любого из списка символов в строке  
      — возможно, автору этого API казалось, что аббревиатура `pbrk` что-то значит для читателя, но он явно ошибся;  
      хорошо: `string_search_for_characters`; однако необходимость существования такого метода вообще вызывает сомнения, достаточно было бы иметь удобную функцию поиска подстроки с нужными параметрами.

4. Сущности-массивы должны именоваться во множественном числе или собирательными выражениями — `objects`, `children`; если это невозможно (термин неисчисляемый), следует добавить префикс или постфикс, не оставляющий сомнений:
    * плохо: `GET /news`
      — неясно, будет ли получена какая-то конкретная новость или массив новостей;
      хорошо: `GET /news-list`.

5. Аналогично, если ожидается булево значение, то из названия это должно быть очевидно, т.е. именование должно описывать некоторое качественное состояние, например, `is_ready`, `open_now`:
    * плохо: `"task.status": true`
      — неочевидно, что статус бинарен, плюс такое API будет нерасширяемым  
      хорошо: `"task.is_finished": true`

6. Сущности, выполняющие подобные функции, должны называться подобно и вести себя подобным образом.
    * плохо: `begin_transition` / `stop_transition`  
      — `begin` и `stop` — непарные термины; разработчик будет вынужден рыться в документации;  
      хорошо: `begin_transition` / `end_transition` либо `start_transition` / `stop_transition`;
    * плохо:  
      `strpos(haystack, needle)` — ищет позицию строки `needle` внутри строки `haystack`;  
      `str_replace(needle, replace, haystack)` — заменяет вхождения строки `needle` внутри строки `haystack` на строку `replace`;  
      — здесь нарушены сразу несколько правил: написание неконсистентно в части знака подчеркивания; близкие по смыслу методы имеют разный порядок аргументов `needle`/`haystack`; наконец, один из методов находит первое вхождение, а другой — все вхождения, и это никак не отражено в именовании.

// TODO: единицы измерения, различные стандарты, консистентность
// TODO: простые вещи делаются просто без бойлерплейта